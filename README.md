# AI Crypto Advisor
AI Crypto Advisor is a personalized crypto dashboard that adapts to each userâ€™s interests. After creating an account and choosing the coins, investor style, and types of content they like, the app automatically builds a customized home feed. It displays live crypto prices, trending market news, social sentiment insights, fun memes, and lets users like or dislike items to further improve their recommendations. The goal is to make crypto information easier to follow, more relevant, and actually enjoyable with all in one place.

## Features
* Authentication â€“ users can register and log in using email and password. Passwords are hashed with bcrypt and JSON Web Tokens (JWT) are used for authentication.
* Onboarding quiz â€“ after first login, users answer a few questions about their favourite crypto assets, investor type and preferred content categories. Answers are stored in the database.
* Daily dashboard â€“ once onboarding is complete, users see a dashboard with four sections:
  * Market News: top crypto headlines from CryptoPanic with a static fallback.
  * Coin Prices: live USD prices and 24â€‘hour percentage change for the userâ€™s selected assets via CoinGecko.
  * AI Insight: a short, actionable daily insight generated by a configurable LLM endpoint OpenRouter. A fallback is used if the endpoint is not configured.
  * Fun Meme: a randomly selected crypto meme image.
* Feedback buttons â€“ each section has ğŸ‘ and ğŸ‘ buttons. Votes are persisted so you can later train a ranking model or tailor future recommendations.
* API first â€“ the backend exposes RESTful endpoints under `/api` for authentication, preferences, dashboard and feedback.
* Clean UI â€“ the frontend is built with React and Vite and styled with a dark theme. It works on desktop and mobile.

## Project structure
```
crypto-advisor/
â”œâ”€ backend/           # Node.js + Express API
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ controllers/
â”‚  â”‚  â”œâ”€ middleware/
â”‚  â”‚  â”œâ”€ routes/
â”‚  â”‚  â”œâ”€ utils/
â”‚  â”‚  â”œâ”€ db.js
â”‚  â”‚  â””â”€ index.js
â”‚  â”œâ”€ database.sqlite # SQLite database (created on first run)
â”‚  â”œâ”€ .env.example    # Sample environment variables
â”‚  â””â”€ package.json
â”œâ”€ frontend/          # Vite + React singleâ€‘page app
â”‚  â”œâ”€ src/
â”‚  â”‚  â”œâ”€ pages/
â”‚  â”‚  â””â”€ App.jsx
â”‚  â”œâ”€ index.html
â”‚  â”œâ”€ vite.config.js
â”‚  â””â”€ package.json
â””â”€ README.md          # This file
```

## Getting started locally
The backend uses Node.js, Express and SQLite. The frontend uses React** and Vite. Follow these steps to run both in development:

1. Clone the repository and install backend dependencies:

   ```bash
   cd backend
   npm install
   ```

2. Copy `.env.example` to `.env` and set your configuration:

   ```bash
   cp .env.example .env
   # Edit .env to set JWT_SECRET and optionally AI_API_URL, AI_API_TOKEN and CRYPTOPANIC_TOKEN
   ```

3. Start the backend:

   ```bash
   npm run dev
   ```

   The API will listen on `http://localhost:4000` by default and create a `database.sqlite` file on first run.

4. In another terminal, install frontend dependencies and start the dev server:

   ```bash
   cd ../frontend
   npm install
   npm run dev
   ```

   The app will be available at `http://localhost:5173`. During development, Vite proxies API requests to the backend.

5. Open the app in your browser, register a new user and complete the onboarding quiz. You should then see your personalized dashboard.

## AI tools usage
This solution was planned with the help of AI (ChatGPT) to sketch the architecture, database schema and API structure. The code itself is hand written to match the task requirements. A configurable AI endpoint is used to generate the daily insight. The default is a OpenRouter inference endpoint. You can plug in any compatible model by setting `AI_API_URL` and `AI_API_TOKEN` in the `.env` file.

## Bonus: feedback training suggestions
As part of improving the quality of recommendations, the feedback system was updated to use an XOR-style like/dislike toggle. This means that for each content item (such as a news article or price card), a user can either like it, dislike it, or clear their response, but never both at the same time. Every piece of feedback is stored in the database in a normalized form (vote = 1 for like, -1 for dislike, and no row when cleared), making it very easy to aggregate and analyze later. Although the current system does not train any models automatically, this structure makes it straightforward to use the stored feedback signals in a future training loop: for example, collecting which topics or asset types users consistently like could guide a recommendation model to prioritize similar content, while disliked items could be used to reduce certain content types for the user. In other words, this feedback format is already in a machine learning friendly shape and can be plugged into model training or ranking adjustments later without needing to redesign the database. Let's say we can Define a per-impression label:
	â€¢	If user saw item X and then liked it within T hours: label = 1.
	â€¢	If user saw item X and explicitly disliked: label = 0.
	â€¢	If user saw but neither liked nor clicked after Î”t: treat as implicit negative with smaller weight.
	â€¢	If user clicked but didnâ€™t like/dislike: treat as weak positive.